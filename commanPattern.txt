

nums.erase(nums.begin() + index);  //delete elem at i index  tc=O(n), sc=O(1)
int mx = *max_element(nums.begin(), nums.end());   //maxElem find  tc=O(n), sc=O(1)
sort(nums.begin(), nums.end());   //sortArr using c++ STL  tc=O(nLogN), sc=O(logN) due to recurssive Quick + Heap + Insertion sort





Repo Link:   https://github.com/ankit485803/MyAdvDSA_PathwayToCP

recursion funct -- TC formula =  total calls * work done in each call 


2nd Sep 2024 (Monday) se start this series DSA with cpp on free Apna College YouTube Channel, after 
ankit came froom IIIT Guwahati



Here,
 we'll mention all the concepts that we learn and observe on the practice the DSA prob from the various topics






1. Three prob (Book Alloc + Painter Parition + Aggressive Cows) -- learn min(max), max(min) to ans = range,then apply Binary Search 

2.  Sorting Algo: yah DSA ques (LeetCode) ko solve karne ke liye use nahi karte h, but Interview / HR mai ques puch sakta h
    ankit maje karo enjoy tumhara ye topics complete h pahle (GATE SAMASHER se kiye ho Sem2 IIT Patna mai) only recap from the short notes okkkk bhai

3.  The one-pass algorithm for sorting colors, commonly known as the Dutch National Flag (DNF) algorithm, 
efficiently sorts an array containing three distinct values (in this case, 0s, 1s, and 2s) in a single traversal. 

this DNF is based on Netherland flag colors: C:\Users\sanja\Desktop\GitProj\MyAdvDSA_PathwayToCP\01_LeetCode\sortColor.cpp



4. In permutation of string ques - if Constraints in ques given -- lowecase + uppercase + specailChar + digits. In this case hnko nahi pata h kitna freq hai, then
then it's solutin hai aap ek unordered map create karo and store <char, int> will read in HASTING chapter

search s1 permutation in s2 using     WINDOW BASED SEARCHING tecniq 



5. HASTING (map, set) -- jiska kam h Complex ko O(1) CONSTANT bana dena, (ankit use this cocnept in twoSum prob- leetcode.com/problems/two-sum/)


6. Slow-Fast pointer approach (in LinkedList chapter ) but ankit solve in FindDup, This method is used to detect the CYCLE in linked list 
    method1: BruteForce -- ans = (size/2  + 1)
    method2: SLOW-FAST POINTER approach to find middle of LL, this approach is also used in next topic: CYCLE-DETECTION in LL
    I write this ppoint on 7th Jan 2025 (Tueday) from NESAC ISRO Meghalaya Centre
    


7. No, the current recursive method will not work for negative numbers like -15, because it is designed to calculate the sum of 
positive integers starting from 1 to n. Recursion assumes 
that you're summing up from 1 upwards, and it depends on a positive base case (n = 1), which doesn't apply to negative numbers.


8. TC = total call * work done in each call 
GCD = HCF
formula
LCM(a, b) = |a*b| divide by GCD(a, b)

Optimized Approach - O(N) using a Prefix Sum Technique
Instead of calculating divisors separately for each number, we can efficiently compute F(i) for all i from 1 to N in O(N) time using a smart trick.

https://www.geeksforgeeks.org/problems/sum-of-all-divisors-from-1-to-n4738/1



Note: jab bhi hmko tree ka ques aaye to hmko RECURSION kw tarh sochna hai -- told by Shardha didi (Chapter_DS\NonLinear\01_BinaryTree\Height_of_BT\height_LecNo_84.cpp)


9. Sum of two numb without + and - operators: hint yaha concepts of BitWise operators (AND, OR, XOR, left right shift) hoga

10. Sliding window problems


11.  find(), and rfind() keywords uses:     C:\Users\sanja\Desktop\GitProj\MyAdvDSA_PathwayToCP\0_Arjuna_CP\D41_Onward_Sem5\q29_NoPerfectPairs_SeparateBlackWhiteBall.cpp
rfind(sub, 0) == 0 → means “does this string start with sub?”
rfind() by itself → “find me the last occurrence of sub.”


12.  prefix-Suffix method

Prefix based problems approach:   leftSum[i] = leftSum[i-1] + nums[i-1]  and similarly rightSum
0_Arjuna_CP\D41_Onward_Sem5\Nov\q7_partitionList_minOperations_prefixLeftRightSum.cpp




13. BucketRadixSortApproach : 0_Arjuna_CP\D41_Onward_Sem5\Nov\q9_reverseLL_maxGap.cpp

qno 164  https://leetcode.com/problems/maximum-gap/
Bucket Sort is great for uniformly distributed data, especially for floating-point numbers within a known range. 
It can be inefficient when the data isn’t uniformly distributed.

Radix Sort is typically used for sorting large datasets of integers or strings where the number of digits (or characters) is small relative to the number of elements. 
It's very efficient when sorting integers or fixed-length strings.


14. StrLengthProp-ConcateTrick to check repeatedStrPattern 

 0_Arjuna_CP\D41_Onward_Sem5\Nov\q13_reorderList_sortList_IsSeq_repeatedStrPattern.cpp

qno 459  https://leetcode.com/problems/repeated-substring-pattern/description/



15.  Kadane's Algorithm is an efficient way to find the maximum sum of a contiguous subarray in a given array of integers. 
It operates in O(n) time complexity, where n is the length of the array.

    qno 3381  https://leetcode.com/problems/maximum-subarray-sum-with-length-divisible-by-k/
    0_Arjuna_CP\D41_Onward_Sem5\Nov\q21_maxSubarrSum.cpp






16.  Enumeration: Systematically checking all valid possibilities that satisfy given constraints.
Sieve of Eratosthenes: algo to find all primeNo upto n efficiently

C:\Users\sanja\Desktop\GitProj\MyAdvDSA_PathwayToCP\0_Arjuna_CP\HappyNewYr26\01_Jan\q19_maxIceCream_Sieve of Eratosthene.cpp
https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes









To learn:-
imp function to convert int to str:  to_string(count)

Learn DSA using project
src link: https://youtube.com/shorts/Ve0muiObnrY?si=i7H6t4RmcE7PKOYt

a. Snake Game: make from array + loop where handle the Movement & Collision detection 
b. Cash Flow Minimization: uses Graph + Heap -- graph traversal & mini heap concepts
c. Pseudo Solver: Backtracking algorithm - to manage recursive calls and Constraints to solve the complex puzzle

d. File Zipper: Huffman Encoding se aap data ko compression karo,  Greedy algo se optimal code generate karo jo compression RATIO ko
                    ko increase kar dega + efficiency ko increase kar dega

e. Map Navigator: jo Dijistra algo use karte h shotest path ko find out kata hai




someImpQues-BT:  
C:\Users\sanja\Desktop\GitProj\MyAdvDSA_PathwayToCP\0_Arjuna_CP\HappyNewYr26\01_Jan\q24_diameterBT_subTree_symmetricTree_sameTree_minPairSum.cpp

